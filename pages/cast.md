---
title: cast
---

## static_cast
### static_cast <T> content：静态转换，在编译期间处理
### 主要用于C++中内置的基本数据类型之间的转换，但是没有运行时类型的检测来保证转换的安全性。还用于各种隐式转换，比如非`const`转`const`，`void*`转指针等
1.用于基类和子类之间的指针或引用的转换。把子类的指针或引用转换为基类表示时（向上转换）是安全的；但把基类的指针或引用转换为用子类表示时（向下转换），由于没有进行动态类型检测，所以是不安全的。
2.用于把`void`型指针转换为目标类型的指针，此转换不安全
3.用于内置的基本数据类型之间的转换
4.用于把任何类型的表达式转换为`void`型
5.用于基本数据类型（`char`、`int`等）以及对象之间的转换
6.不能用于基本数据类型（`char*`、`int*`等）指针之间的转换
需要注意的是，`static_cast`只转换类型，不改变属性，即`content`的`const`、`volatile`、`unaligned`的属性是不会改变的
## const_cast
### `const_cast <T*> content`：去常转换，编译时执行
### 主要作用于同一个类型之间的去长和添加常属性之间的转换，但不能用作不同类型之间的转换。它可以把一个不是常属性（const）的转换成常属性的，同时也可以对一个本是常属性的类型进行去长操作，即const变量转非const。
常用于去除const类对象的只读属性，且强制转换的类型必须是指针或引用。
## dynamic_cast
### dynamic_cast <T*> content：动态类型转换，运行时执行
### 通常用于基类和派生类之间的转换，转换时会进行类型安全检查。只能用于含有虚函数的类，用于类层次间的向上和向下转换。只能转指针或引用。
通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
1.不能用于内置的基本数据类型之间的转换
2.不能用于基本数据类型指针（`char*`、`int*`）之间的转换
3.转换成功，返回的是类的指针或引用，失败，返回NULL
4.进行转换的时候基类中一定要有虚函数的支持。因为只有类中有虚函数，才说明它希望让基类指针或引用指向其派生类对象，这样转换才有意义。
5.在类的转换时，在类次间进行转换的时候dynamic_cast和static_cast进行向上转换时，它们的转换效果是一样的；但是向下转换时，dynamic_cast会进行类型检查，所以它比static_cast更安全。它也可以让指向基类的指针转换为指向其子类的指针或是其兄弟类的指针（交叉关系的类指针）。
6.具有类型检查的功能，编译时会去检查使用的方法是否正确，转换是否成功只有在程序运行时才能知道
## reinterpret_cast
### `reinterpret_cast <T*> content`：重解释类型转换，几乎什么都可以转。
### 它有着和C语言中强制转换一样的功能，它可以把任何的内置数据类型转换为其他的类型，同时它也可以把任何类型的指针转换为其他的类型。它的机制是对二进制数据进行重新的解释，不会改变原来的格式，而`static_cast`则会改变原来的格式。
## **为什么不使用C的强制转换**
### c的强制转换表面上看起来功能强大，什么都可以转，但是转换不够明确，不能进行错误检查，容易出错
